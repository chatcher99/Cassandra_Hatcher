from __future__ import divisionimport sysfrom math import*import numpy as npfrom numpy import*'''def Scatter(nph):        outfile_E=open('Scatter_E_Fields.dat','w')    outfile_K=open('Scatter_Vectors.dat','w')    for p in range(nph):        # first we create the incoming propagation vector K and electric field E        K=array([1,0,0])        Sigma=np.random.rand()*(pi)                   #generating random angle of E prop.         E=array([0,cos(Sigma),sin(Sigma)])        #print np.dot(E,K)                # we then rotate the frames so that the electric field is in the y direction        Ep=Rotation(E,-Sigma)        Kp=K        #print np.dot(Ep,K)                # we now generate the scattering angles          Theta=Theta_Find(100)                           #Theta is off of y axis in xy plane (probability proportional to Theta^3)        Phi=np.random.rand()*2*pi                       #Phi is off of x axis in xz plane (Randomly generated)        #Find Scattered vector        Kdp = Scatter_Vectors(Kp,Theta,Phi)                #Find Scattered EField        Edp=Scatter_EField(K,Kdp, Ep)        #print (np.dot(Edp,Kdp))                #Counter rotate scattered EField and vector        Etp=Rotation(Edp,Sigma)        Ktp=Rotation(Kdp,Sigma)        #print (np.dot(Etp,Ktp))                #create files to store vector data        writestring_E=str(Etp[0])+'\t'+str(Etp[1])+'\t'+str(Etp[2])+'\n'        outfile_E.write(writestring_E)        writestring_K=str(Ktp[0])+'\t'+str(Ktp[1])+'\t'+str(Ktp[2])+'\n'                outfile_K.write(writestring_K)            outfile_E.close()    outfile_K.close()    return '''def Theta_Find(num_pts):    XX=[]    for i in range(num_pts):                  #generate random x values for sine graph and scatter        x=np.random.rand()*np.pi              #same x values for both sine scatter allows for easier comparison because we can now just focus on the discrpancies in Y values        XX.append(x)    Xsine=XX                                  #sort random values so that when plotting sine it will be correct    Ysine=np.sin(Xsine)**3                    #generates y values for sin^3 graph    YY=[]    for t in range(len(Xsine)):               #generates random y value for random scatter, for every X value.         y=np.random.rand()                           YY.append(y)    Xscat=[]            Yscat=[]    for i in range(len(YY)):                  #compares y values of scatter to y values of sine at cooresponding x values        if YY[i]<= Ysine[i]:            Yscat.append(YY[i])            Xscat.append(Xsine[i])    Theta=Xscat[0]    #print "Theta: "+str(Theta)    return Thetadef Scatter_Vectors(K,Theta,Phi):        Kxx=sin(Theta)*cos(Phi)    Kyy=cos(Theta)    Kzz=sin(Theta)*sin(Phi)        Kdp=(Kxx,Kyy,Kzz)                                #Scatter Vector    return np.array(Kdp)def Scatter_EField(K,Kdp,Ep):        L=np.cross(Kdp,Ep)                                 #vector orthoganal to the plane formed by E and KK        Lx=L[0]    Ly=L[1]    Lz=L[2]    Kxx=Kdp[0]    Kyy=Kdp[1]    Kzz=Kdp[2]    Exx= (1/(1+((Ly*(Kxx-(Lx*Kzz/Lz)))/(Lz*(Kyy-(Ly*Kzz/Lz))))**2+(-(Kxx-(Lx*Kzz/Lz))/(Kyy-(Ly*Kzz/Lz)))**2))**(1/2)    Eyy= - Exx*(Kxx-(Lx*Kzz/Lz))/(Kyy-(Ly*Kzz/Lz))    Ezz= (Exx/Lz)*((Ly*(Kxx-(Lx*Kzz/Lz))/(Kyy-(Ly*Kzz/Lz)))-Lx)    Edp=np.array([Exx,Eyy,Ezz])    Edp=Edp/np.sqrt(np.sum(Edp**2))                                   #E field of propogation    return Edpdef Rotation(E,Sigma):    Rotate=np.matrix([[1,0,0],[0,np.cos(Sigma),np.sin(Sigma)],[0,-np.sin(Sigma),np.cos(Sigma)]])    Erotate=E*Rotate    Erotate2=np.empty(3)    Erotate2[0]=Erotate[0,0]    Erotate2[1]=Erotate[0,1]    Erotate2[2]=Erotate[0,2]    return Erotate2def EField_Comps(Detect,nph):    #Select Vectors in Direction of Detector     kx,ky,kz=loadtxt('Exit_Vectors.dat',unpack=True)    Ex,Ey,Ez=loadtxt('Exit_EFields.dat',unpack=True)    outfile_SV=open('Selected_Exit_Vectors.dat','w')    outfile_SE=open('Selected_Exit_EFields.dat','w')        #Detect=np.array([0.001,0.001,1])    #print "Detector: " +str(Detect)    DetLength=np.linalg.norm(Detect)    DFD=5                  #degrees off of detector vector that are accepted    i=0    while i < nph:              vect=np.array([kx[i],ky[i],kz[i]])          #takes vector        VectLength=np.linalg.norm(vect)             #norm of vector        a=(np.dot(vect,Detect))/(DetLength*VectLength)  #determines the angles between the scatter vector and the detector vector        omega=np.arccos(a)        if omega <= np.deg2rad(DFD):        #if this angle is within our degreees of freedom = keep            writestring_SV=str(kx[i])+'\t'+str(ky[i])+'\t'+str(kz[i])+'\n'            outfile_SV.write(writestring_SV)            writestring_SE=str(Ex[i])+'\t'+str(Ey[i])+'\t'+str(Ez[i])+'\n'            outfile_SE.write(writestring_SE)        i+=1    outfile_SV.close()    outfile_SE.close()    x,y,z=loadtxt('Selected_Exit_Vectors.dat',unpack=True)    Ex,Ey,Ez=loadtxt('Selected_Exit_EFields.dat',unpack=True)    #Find EField Compents in Detector Reference Frame    outfile_EC=open('Exit_EField_Comps.dat','w')    D=Detect    XD=np.array((1/(D[0]**2+D[1]**2+D[2]**2))**(1/2)*D)                                        #direction of detector=xaxis of detector reference frame=line through back of detector    ZD=np.array([ (-sign(XD[0])*XD[2]/(XD[0]**2+XD[2]**2)**(1/2)) , 0 , (1-(XD[2]**2/(XD[0]**2+XD[2]**2)))**(1/2) ])     #z axis of the detector    Zy= (1/((XD[0]**2/XD[2]**2)+((XD[0]**2+XD[2]**2)**2/(XD[1]**2*XD[2]**2))+1))**(1/2)    YD=np.array([(Zy*XD[0]/XD[2]), -((Zy/XD[1])*((XD[0]**2+XD[2]**2)/XD[2])), Zy])     #is the yaxis of the detector reference frame    #print "Number of Photons: " +str(len(Ex))    for i in range(Ex.size):        E=(Ex[i],Ey[i],Ez[i])        Ecx=np.dot(E,XD)/np.linalg.norm(XD)        Ecy=np.dot(E,YD)/np.linalg.norm(YD)        Ecz=np.dot(E,ZD)/np.linalg.norm(ZD)        writestring_EC=str(Ecx)+'\t'+str(Ecy)+'\t'+str(Ecz)+'\n'        outfile_EC.write(writestring_EC)                    Ep=(Ecx,Ecy,Ecz)    outfile_EC.close()    return  def Stokes(EFieldComps):    #Calculate componets of Efields on each axis    Ecx,Ecy,Ecz=loadtxt('Exit_EField_Comps.dat', unpack=True)    outfile_P=open('Polarization_NEW.dat','w')            a=array([sqrt(2),sqrt(2)])          #rotates axes    b=array([sqrt(2),-sqrt(2)])    EZ=np.zeros([Ecx.size])    EY=np.zeros([Ecx.size])    Ea=np.zeros([Ecx.size])    Eb=np.zeros([Ecx.size])            for i in range(Ecx.size):        Ec=array([Ecy[i], Ecz[i]])        EZ[i]=Ecz[i]        EY[i]=Ecy[i]        Ea[i]=np.dot(Ec,a)        Eb[i]=np.dot(Ec,b)    #Compute Stokes Parameters    EZ2=EZ**2    EY2=EY**2    Ea2=Ea**2    Eb2=Eb**2    I=sum(EZ2)/Ecx.size + sum(EY2)/Ecx.size    Q=sum(EZ2)/Ecx.size - sum(EY2)/Ecx.size    U=sum(Ea2)/Ecx.size - sum(Eb2)/Ecx.size    P=np.sqrt(Q**2+U**2)/I    outfile_P.write(str(P))    outfile_P.close()    return Pdef Rot3D(K,Theta,Phi):        RotateY=np.matrix([[np.cos(Phi),0,-np.sin(Phi)],[0,1,0],[np.sin(Phi),0,np.cos(Phi)]])        RotateZ=np.matrix([[np.cos(Theta),-np.sin(Theta),0],[np.sin(Theta),np.cos(Theta),0],[0,0,1]])        KRot=K*RotateY          #K vector after rotation about y axis        KK=KRot*RotateZ         #K vector after rotation about z axis                KR= np.empty(3)         KR[0]=KK[0,0]        KR[1]=KK[0,1]        KR[2]=KK[0,2]            return KRdef CoRot3D(K,Theta,Phi):                RotateY=np.matrix([[np.cos(Phi),0,-np.sin(Phi)],[0,1,0],[np.sin(Phi),0,np.cos(Phi)]])        RotateZ=np.matrix([[np.cos(Theta),-np.sin(Theta),0],[np.sin(Theta),np.cos(Theta),0],[0,0,1]])        KRot=K*RotateZ          #K vector after rotation about y axis        KK=KRot*RotateY         #K vector after rotation about z axis                KR= np.empty(3)         KR[0]=KK[0,0]        KR[1]=KK[0,1]        KR[2]=KK[0,2]            return KRdef Propagation(Lambda):    ###Shoot Photon in random Direction###    d=Lambda*(-np.log(np.random.rand()))        #distance traveled based on mean free path    k=np.array([d,0,0])    Sigma=np.random.rand()*(pi)             #Random angle for Efield     e=array([0,cos(Sigma),sin(Sigma)])    ee=Rotation(e,-Sigma)    Theta=np.pi/2 #np.arccos((np.random.rand()*2)-1)     #randomly generate direction of photon     Phi= 0 # np.random.rand()*2*np.pi    K=k#Rot3D(k,-Theta,-Phi)                         #Propagation Vector    E=e#Rot3D(ee,-Theta,-Phi)    print("Dot K E: "+str(np.dot(K,E)))    return K,E,Theta,Phi,ddef EllipCloud(Theta,Phi,a,b,c):    #outer radii of ellipitcal cloud    X=a*np.outer(np.cos(Phi),np.sin(Theta))    Y=c*np.outer(np.ones(np.size(Phi)),np.cos(Theta))    Z=b*np.outer(np.sin(Phi),np.sin(Theta))    R=(X**2+Y**2+Z**2)**(1/2)        return Rdef ComptonScatter(K,E,Lambda,Theta,Phi):    #print("Dot K E: "+str(np.dot(K,E)))    ## 1st Rotation ###Rotate K to (1,0,0)    ThetaPrime=pi/2-Theta    KR = Rot3D(K,ThetaPrime,Phi)    #print("KR: " +str(KR))    ER = Rot3D(E,ThetaPrime,Phi)    #print("ER: " +str(ER))    print("Dot KR ER: "+str(np.dot(KR,ER)))    ## 2nd Rotation ###Rotate ER to (0,1,0)    #find angle ER is away from y axis now    ER_L=np.linalg.norm(ER)    Omega=np.arccos(ER[1]/ER_L)    #print("Omega: "+str(Omega))       #find angle Eqp is away from Z axis now    if np.sign(ER[0]) == 1:        if np.sign(ER[2]) == 1:            PsiER = np.arctan(ER[0]/ER[2])        if np.sign(ER[2]) == -1:            PsiER=(np.pi/2)+ np.abs(np.arctan(ER[2]/ER[0]))                        if np.sign(ER[0]) == -1:        if np.sign(ER[2]) == 1:            PsiER =(3*np.pi/2)+np.abs(np.arctan(ER[2]/ER[0]))        if np.sign(ER[2]) == -1:            PsiER=(np.pi)+ np.arctan(ER[0]/ER[2])        if np.sign(ER[2])==0:        PsiER=np.pi/2    if np.sign(ER[0])==0:        PsiER=0    #else:     #   PsiER=np.arctan(ER[0]/ER[2])            #print("PsiER: "+str(PsiER))    RotateY=np.matrix([[np.cos(PsiER),0,np.sin(PsiER)],[0,1,0],[-np.sin(PsiER),0,np.cos(PsiER)]])    Er=ER*RotateY    #print("Er: "+str(Er))    Ep = Rotation(Er,Omega)    Kp = KR    #print("Kp: "+str(Kp))    #print("Ep: "+str(Ep))    print("Dot Kp Ep: "+str(np.dot(Kp,Ep)))    # we now generate the scattering angles      Theta1=Theta_Find(100)                           #Theta is off of y axis in xy plane (probability proportional to Theta^3)    Phi1=np.random.rand()*2*pi                       #Phi is off of x axis in xz plane (Randomly generated)      #Find Scattered vector    d=Lambda*(-np.log(np.random.rand()))    Kdp =d*(Scatter_Vectors(Kp,Theta1,Phi1))    #print("Kdp: "+str(Kdp))    #Find Scattered EField    Edp=Scatter_EField(K,Kdp,Ep)         #print("Edp: "+str(Edp))    print("Dot Kdp Edp: "+str(np.dot(Kdp,Edp)))    ## 3rd Rotation ###Counter rotate 2nd rotation     RotateYCount=np.matrix([[np.cos(-PsiER),0,np.sin(-PsiER)],[0,1,0],[-np.sin(-PsiER),0,np.cos(-PsiER)]])    ETP=Rotation(Edp,Omega)    KTP=Rotation(Kdp,Omega)    ETp=(ETP*RotateYCount)    KTp=(KTP*RotateYCount)    Etp= np.empty(3)     Etp[0]=ETp[0,0]    Etp[1]=ETp[0,1]    Etp[2]=ETp[0,2]        Ktp= np.empty(3)     Ktp[0]=KTp[0,0]    Ktp[1]=KTp[0,1]    Ktp[2]=KTp[0,2]    #print("Ktp: "+str(Ktp))    #print("Etp: "+str(Etp))    print("Dot Ktp Etp: "+str(np.dot(Ktp,Etp)))    ## 4th Rotation ###Counter rotate 1st rotation      Kqp = CoRot3D(Ktp,-ThetaPrime,-Phi)    Eqp = CoRot3D(Etp,-ThetaPrime,-Phi)    #print("Kqp: "+str(Kqp))    #print("Eqp: "+str(Eqp))    print("Dot Kqp Eqp: "+str(np.dot(Kqp,Eqp)))        ## Find New angles ##    #find angle Kqp is away from y axis now    Kqp_L=np.linalg.norm(Kqp)    Zeta=np.arccos(Kqp[1]/Kqp_L)    #find angle Kqp is away from x axis now    if np.sign(Kqp[0]) == 1:        if np.sign(Kqp[2]) == 1:            Psi = np.arctan(Kqp[2]/Kqp[0])        if np.sign(Kqp[2]) == -1:            Psi =(3*np.pi/2)+np.abs(np.arctan(Kqp[0]/Kqp[2]))                    if np.sign(Kqp[0]) == -1:        if np.sign(Kqp[2]) == 1:            Psi =(np.pi/2)+ np.abs(np.arctan(Kqp[0]/Kqp[2]))        if np.sign(Kqp[2]) == -1:            Psi =(np.pi)+ np.arctan(Kqp[2]/Kqp[0])    if np.sign(Kqp[2])==0:        Psi=0    if np.sign(Kqp[0])==0:        Psi=np.pi/2    #else:        #Psi=np.arctan(Kqp[2]/Kqp[0])            return Kqp,Eqp,Zeta,Psi,ddef Cloud_Scatter(nph,a,b,c):    outfile_V=open('Exit_Vectors.dat','w')    outfile_E=open('Exit_EFields.dat','w')    ####Define parameters####    C=3.0*10**8             #m/s    #a=3*10**10              #m semimajor x axis     #b=10**10                #m semiminor z axis axis    #c=b                     #m semininor y axis    alpha = 1.5    Lambda = alpha*a       #R/T #Mean Free Path    TimeS=np.empty(nph)     #create empty array for time values     for p in range(nph):        K,E,Theta,Phi,d=Propagation(Lambda)         #Create Initial Propagation Vector                R=EllipCloud(Theta,Phi,a,b,c)[0,0]      #Radius of cloud at angle of propagation        X=K[0]        Y=K[1]        Z=K[2]        D=np.linalg.norm(K)                     #Distance from orgin        #Sigma=np.random.rand()*(pi)             #Random angle for Efield         #E=array([0,cos(Sigma),sin(Sigma)])                i=0        TimeT=np.linalg.norm(K)/C               #initial time of travel        #print("K: "+str(K))        while D < R:                            #Scatter Process            #print("K: "+str(K))            Kqp,Eqp,Zeta,Psi,d = ComptonScatter(K,E,Lambda,Theta,Phi)    #rotates K to (1,0,0) and E to (0,1,0) then scatters and counter rotates            #print ('Kqp: '+str(Kqp))            X=X+Kqp[0]            Y=Y+Kqp[1]            Z=Z+Kqp[2]            D=(X**2+Y**2+Z**2)**(1/2)                            #find angle D is away from y axis now            ThetaR=np.arccos(Y/D)            #find angle D is away from x axis now            if np.sign(X) == 1:                if np.sign(Z) == 1:                    PhiR = np.arctan(Z/X)                if np.sign(Z) == -1:                    PhiR =(3*np.pi/2)+np.abs(np.arctan(X/Z))                                    if np.sign(X) == -1:                if np.sign(Z) == 1:                    PhiR =(np.pi/2)+ np.abs(np.arctan(X/Z))                if np.sign(Z) == -1:                    PhiR =(np.pi)+ np.arctan(Z/X)            if np.sign(Z)==0:                PhiR=0            if np.sign(X)==0:                PhiR=np.pi/2            R=EllipCloud(ThetaR,PhiR,a,b,c)[0,0]      #Radius at angle of scatte                        K = Kqp                        E = Eqp            Theta = Zeta            Phi = Psi            Time=(np.linalg.norm(K)/C)                                  #Time per scatter displacement            TimeT=TimeT+Time                            #Total Time of photon motion            i+=1        #print ('Number of Scatters: '+str(i))        Rd=D-R                                          #Distance traveled after leaving the star         if TimeT==0:            TimeS[p]=0        else:            TimeS[p]=(TimeT-(Rd/C))                         #Total time of photon motion while in the star           writestring_V=str(K[0])+'\t'+str(K[1])+'\t'+str(K[2])+'\n'        writestring_E=str(E[0])+'\t'+str(E[1])+'\t'+str(E[2])+'\n'        outfile_V.write(writestring_V)        outfile_E.write(writestring_E)           outfile_V.close()    outfile_E.close()        return