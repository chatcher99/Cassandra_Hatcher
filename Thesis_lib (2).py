from __future__ import divisionimport sysfrom math import*import numpyfrom numpy import*import randomfrom matplotlib import pyplot as pltdef Theta_Find(num_pts):    XX=[]    for i in range(num_pts):                        #generate random x values for sine graph and scatter        x=numpy.random.rand()*numpy.pi              #same x values for both sine scatter allows for easier comparison because we can now just focus on the discrpancies in Y values        XX.append(x)    Xsine=XX                                        #sort random values so that when plotting sin it will be correct    Ysine=numpy.sin(Xsine)**3                       #generates y values for sin^3 graph    YY=[]    for t in range(len(Xsine)):                     #generates random y value for random scatter, for every X value.         y=numpy.random.rand()                           YY.append(y)    Xscat=[]            Yscat=[]    for i in range(len(YY)):                        #compares y values of scatter to y values of sin at cooresponding x values        if YY[i]<= Ysine[i]:            Yscat.append(YY[i])            Xscat.append(Xsine[i])    Theta=Xscat[0]    #print "Theta: "+str(Theta)    return Thetadef Scatter_Vectors(K,Theta,Phi):        Kxx=sin(Theta)*cos(Phi)    Kyy=cos(Theta)    Kzz=sin(Theta)*sin(Phi)        Kdp=(Kxx,Kyy,Kzz)                                #Scatter Vector    return numpy.array(Kdp)def Scatter_EField(K,Kdp,E):        L=numpy.cross(Kdp,E)                                 #vector orthoganal to the plane formed by E and KK        Lx=L[0]    Ly=L[1]    Lz=L[2]    Kxx=Kdp[0]    Kyy=Kdp[1]    Kzz=Kdp[2]    Exx=((1/(1+((-(Kxx-((Lx*Kzz)/Lz))/(Kyy-((Ly*Kzz)/Lz)))**2)+((-Lx/Lz)+((Ly*(Kxx-((Lx*Kzz)/Lz)))/((Lz*Kyy)-(Ly*Kzz))))**2))**(1/2))    Eyy=Exx*(-(K[0]-((Lx*Kzz)/Lz))/(K[1]-((Ly*Kzz)/Lz)))    Ezz=Exx*((-Lx/Lz)+((Ly*(Kxx-((Lx*Kzz)/Lz)))/((Lz*Kyy)-(Ly*Kzz))))    Edp=(Exx,Eyy,Ezz)                                    #E field of propogation    return numpy.array(Edp)    def Rotation(E,Sigma):    Rotate=numpy.matrix([[1,0,0],[0,numpy.cos(Sigma),numpy.sin(Sigma)],[0,-numpy.sin(Sigma),numpy.cos(Sigma)]])    Erotate=E*Rotate    Erotate2=numpy.empty(3)    Erotate2[0]=Erotate[0,0]    Erotate2[1]=Erotate[0,1]    Erotate2[2]=Erotate[0,2]    return Erotate2    '''def Rotation(E,Sigma):    Rotate=numpy.matrix([[1,0,0],[0,numpy.cos(Sigma),numpy.sin(Sigma)],[0,-numpy.sin(Sigma),numpy.cos(Sigma)]])    Erotate=E*Rotate    return Erotate'''    